{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 LucidaGrande-Bold;\f2\fnil\fcharset0 LucidaGrande;
\f3\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red83\green83\blue83;\red34\green45\blue53;\red242\green242\blue242;
}
{\*\expandedcolortbl;;\cssrgb\c40000\c40000\c40000;\cssrgb\c17647\c23137\c27059;\cssrgb\c96078\c96078\c96078;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid2\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{square\}}{\leveltext\leveltemplateid3\'01\uc0\u9642 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs80 \cf2 \expnd0\expndtw0\kerning0
P1 Suggestions\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\fs32 \cf3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Token is a triplet 
\b \{tokenID, tokenInstance, line#\}
\b0  (if option with line numbers) .\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1
\b \cf3 \kerning1\expnd0\expndtw0 {\listtext	
\f1 \uc0\u9702 
\f0 	}\expnd0\expndtw0\kerning0
tokenID
\b0  can be enumeration (better) or symbolic constant (worse)\
\ls1\ilvl1
\b \kerning1\expnd0\expndtw0 {\listtext	
\f1 \uc0\u9702 
\f0 	}\expnd0\expndtw0\kerning0
tokenInstance
\b0  can be a string or can be some reference to a string table\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1\cf3 \kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9702 
\f0 	}\expnd0\expndtw0\kerning0
the triplet can be struct\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Suggestions for the string reader option\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1\cf3 \kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9702 
\f0 	}\expnd0\expndtw0\kerning0
Implement scanner as 'scanf("%s",data)' and then processing data as below\
\pard\tx1660\tx2160\pardeftab720\li2160\fi-2160\partightenfactor0
\ls1\ilvl2\cf3 \kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9642 
\f0 	}\expnd0\expndtw0\kerning0
if starts with lower case letter and has all alphanumeric characters then it is identifier unless it matches one of the keywords in which case it is the keyword token\
\ls1\ilvl2\kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9642 
\f0 	}\expnd0\expndtw0\kerning0
if starts with digit and it is all digits then it is an integer token\
\ls1\ilvl2\kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9642 
\f0 	}\expnd0\expndtw0\kerning0
etc.\
\ls1\ilvl2\kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9642 
\f0 	}\expnd0\expndtw0\kerning0
else it is an error\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Alternative suggestion for the same\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1\cf3 \kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9702 
\f0 	}\expnd0\expndtw0\kerning0
Enter each fixed token (exclude identifiers and integers) into associative array where the fixed token is the key as string and the value is the corresponding token.\
\pard\tx1660\tx2160\pardeftab720\li2160\fi-2160\partightenfactor0
\ls1\ilvl2\cf3 \kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9642 
\f0 	}\expnd0\expndtw0\kerning0
If table lookup gives value then just return it (unless comment in which case need another one)\
\ls1\ilvl2\kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9642 
\f0 	}\expnd0\expndtw0\kerning0
Else check if all digits (integer) or else check if matches identifiers\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Suggestions for the FA option\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1\cf3 \kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9702 
\f0 	}\expnd0\expndtw0\kerning0
File can be opened and lookahead character can be set explicitly before the first call to the scanner for the first token\
\ls1\ilvl1\kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9702 
\f0 	}\expnd0\expndtw0\kerning0
Have the scanner not read directly from the file but from a filter. The filter would count lines, skip over spaces and comments, construct string of characters for the current token, and return the column number in the table corresponding to the character\
\ls1\ilvl1\kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9702 
\f0 	}\expnd0\expndtw0\kerning0
Represent the 2-d array for the FSA as array of integers\
\pard\tx1660\tx2160\pardeftab720\li2160\fi-2160\partightenfactor0
\ls1\ilvl2\cf3 \kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9642 
\f0 	}\expnd0\expndtw0\kerning0
0, 1, etc would be states/rows\
\ls1\ilvl2\kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9642 
\f0 	}\expnd0\expndtw0\kerning0
-1, -2, etc could be different errors\
\ls1\ilvl2\kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9642 
\f0 	}\expnd0\expndtw0\kerning0
1001, 1002, etc could be final states recognizing different tokens\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls1\ilvl1\cf3 \kerning1\expnd0\expndtw0 {\listtext	
\f2 \uc0\u9702 
\f0 	}\expnd0\expndtw0\kerning0
Recognize keywords as identifiers in the automaton, then do table lookup\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
To print tokens I would suggest an array of strings describing the tokens, listed in the same order as the tokenID enumeration. For example:\uc0\u8232 
\f3\fs24 \cb4   enum tokenID \{IDENT_tk, NUM_tk, KW_tk, etc\};\cb1 \uc0\u8232 \cb4  string tokenNames[] =\{"Identifier", "Number", "Keyword", etc\};\cb1 \uc0\u8232 \cb4  struct token \{ tokenID, string, int\};\uc0\u8232 
\f0\fs32 \cb1 Then printing tokenNames[tokenID] will print the token description.}